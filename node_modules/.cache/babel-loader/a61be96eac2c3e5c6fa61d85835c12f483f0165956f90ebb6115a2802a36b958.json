{"ast":null,"code":"const RETRY_DELAY = 2000; // 2 seconds\nconst MAX_RETRIES = 3;\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst getSessionToken = async () => {\n  const response = await fetch('https://opentdb.com/api_token.php?command=request');\n  const data = await response.json();\n  return data.token;\n};\nexport const fetchQuizQuestions = async (amount = 10) => {\n  let retries = 0;\n  while (retries < MAX_RETRIES) {\n    try {\n      const response = await fetch(`https://opentdb.com/api.php?amount=${amount}&type=multiple`, {\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (response.status === 429) {\n        retries++;\n        console.log(`Rate limited. Attempt ${retries}/${MAX_RETRIES}. Waiting...`);\n        await delay(RETRY_DELAY);\n        continue;\n      }\n      if (!response.ok) {\n        throw new Error(`Network response was not ok: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.response_code !== 0 || !data.results) {\n        throw new Error('Failed to fetch questions from API');\n      }\n      return data.results.map(question => ({\n        id: Math.random(),\n        question: decodeHTML(question.question),\n        options: shuffleArray([...question.incorrect_answers, question.correct_answer].map(decodeHTML)),\n        correctAnswer: decodeHTML(question.correct_answer)\n      }));\n    } catch (error) {\n      if (retries >= MAX_RETRIES - 1) {\n        console.error('Failed to fetch after multiple retries:', error);\n        throw new Error('Failed to load questions after multiple attempts. Please try again later.');\n      }\n      retries++;\n      await delay(RETRY_DELAY);\n    }\n  }\n  throw new Error('Maximum retry attempts reached');\n};\nconst decodeHTML = html => {\n  const txt = document.createElement('textarea');\n  txt.innerHTML = html;\n  return txt.value;\n};\nconst shuffleArray = array => {\n  return [...array].sort(() => Math.random() - 0.5);\n};","map":{"version":3,"names":["RETRY_DELAY","MAX_RETRIES","delay","ms","Promise","resolve","setTimeout","getSessionToken","response","fetch","data","json","token","fetchQuizQuestions","amount","retries","headers","status","console","log","ok","Error","response_code","results","map","question","id","Math","random","decodeHTML","options","shuffleArray","incorrect_answers","correct_answer","correctAnswer","error","html","txt","document","createElement","innerHTML","value","array","sort"],"sources":["C:/folder mata kuliah/magang dot/quiz-app-react/src/service/quizService.ts"],"sourcesContent":["import { Question } from '../types';\r\n\r\ninterface OpenTDBResponse {\r\n  response_code: number;\r\n  results: {\r\n    category: string;\r\n    type: string;\r\n    difficulty: string;\r\n    question: string;\r\n    correct_answer: string;\r\n    incorrect_answers: string[];\r\n  }[];\r\n}\r\n\r\nconst RETRY_DELAY = 2000; // 2 seconds\r\nconst MAX_RETRIES = 3;\r\n\r\nconst delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\r\nconst getSessionToken = async () => {\r\n  const response = await fetch('https://opentdb.com/api_token.php?command=request');\r\n  const data = await response.json();\r\n  return data.token;\r\n};\r\nexport const fetchQuizQuestions = async (amount: number = 10): Promise<Question[]> => {\r\n  let retries = 0;\r\n\r\n  while (retries < MAX_RETRIES) {\r\n    try {\r\n      const response = await fetch(\r\n        `https://opentdb.com/api.php?amount=${amount}&type=multiple`,\r\n        {\r\n          headers: {\r\n            'Accept': 'application/json',\r\n          },\r\n        }\r\n      );\r\n      \r\n      if (response.status === 429) {\r\n        retries++;\r\n        console.log(`Rate limited. Attempt ${retries}/${MAX_RETRIES}. Waiting...`);\r\n        await delay(RETRY_DELAY);\r\n        continue;\r\n      }\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Network response was not ok: ${response.status}`);\r\n      }\r\n\r\n      const data: OpenTDBResponse = await response.json();\r\n\r\n      if (data.response_code !== 0 || !data.results) {\r\n        throw new Error('Failed to fetch questions from API');\r\n      }\r\n\r\n      return data.results.map((question) => ({\r\n        id: Math.random(),\r\n        question: decodeHTML(question.question),\r\n        options: shuffleArray([\r\n          ...question.incorrect_answers,\r\n          question.correct_answer\r\n        ].map(decodeHTML)),\r\n        correctAnswer: decodeHTML(question.correct_answer)\r\n      }));\r\n    } catch (error) {\r\n      if (retries >= MAX_RETRIES - 1) {\r\n        console.error('Failed to fetch after multiple retries:', error);\r\n        throw new Error('Failed to load questions after multiple attempts. Please try again later.');\r\n      }\r\n      retries++;\r\n      await delay(RETRY_DELAY);\r\n    }\r\n  }\r\n\r\n  throw new Error('Maximum retry attempts reached');\r\n};\r\n\r\nconst decodeHTML = (html: string): string => {\r\n  const txt = document.createElement('textarea');\r\n  txt.innerHTML = html;\r\n  return txt.value;\r\n};\r\n\r\nconst shuffleArray = <T>(array: T[]): T[] => {\r\n  return [...array].sort(() => Math.random() - 0.5);\r\n};"],"mappings":"AAcA,MAAMA,WAAW,GAAG,IAAI,CAAC,CAAC;AAC1B,MAAMC,WAAW,GAAG,CAAC;AAErB,MAAMC,KAAK,GAAIC,EAAU,IAAK,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;AAC7E,MAAMI,eAAe,GAAG,MAAAA,CAAA,KAAY;EAClC,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,mDAAmD,CAAC;EACjF,MAAMC,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC;EAClC,OAAOD,IAAI,CAACE,KAAK;AACnB,CAAC;AACD,OAAO,MAAMC,kBAAkB,GAAG,MAAAA,CAAOC,MAAc,GAAG,EAAE,KAA0B;EACpF,IAAIC,OAAO,GAAG,CAAC;EAEf,OAAOA,OAAO,GAAGd,WAAW,EAAE;IAC5B,IAAI;MACF,MAAMO,QAAQ,GAAG,MAAMC,KAAK,CAC1B,sCAAsCK,MAAM,gBAAgB,EAC5D;QACEE,OAAO,EAAE;UACP,QAAQ,EAAE;QACZ;MACF,CACF,CAAC;MAED,IAAIR,QAAQ,CAACS,MAAM,KAAK,GAAG,EAAE;QAC3BF,OAAO,EAAE;QACTG,OAAO,CAACC,GAAG,CAAC,yBAAyBJ,OAAO,IAAId,WAAW,cAAc,CAAC;QAC1E,MAAMC,KAAK,CAACF,WAAW,CAAC;QACxB;MACF;MAEA,IAAI,CAACQ,QAAQ,CAACY,EAAE,EAAE;QAChB,MAAM,IAAIC,KAAK,CAAC,gCAAgCb,QAAQ,CAACS,MAAM,EAAE,CAAC;MACpE;MAEA,MAAMP,IAAqB,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC;MAEnD,IAAID,IAAI,CAACY,aAAa,KAAK,CAAC,IAAI,CAACZ,IAAI,CAACa,OAAO,EAAE;QAC7C,MAAM,IAAIF,KAAK,CAAC,oCAAoC,CAAC;MACvD;MAEA,OAAOX,IAAI,CAACa,OAAO,CAACC,GAAG,CAAEC,QAAQ,KAAM;QACrCC,EAAE,EAAEC,IAAI,CAACC,MAAM,CAAC,CAAC;QACjBH,QAAQ,EAAEI,UAAU,CAACJ,QAAQ,CAACA,QAAQ,CAAC;QACvCK,OAAO,EAAEC,YAAY,CAAC,CACpB,GAAGN,QAAQ,CAACO,iBAAiB,EAC7BP,QAAQ,CAACQ,cAAc,CACxB,CAACT,GAAG,CAACK,UAAU,CAAC,CAAC;QAClBK,aAAa,EAAEL,UAAU,CAACJ,QAAQ,CAACQ,cAAc;MACnD,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,OAAOE,KAAK,EAAE;MACd,IAAIpB,OAAO,IAAId,WAAW,GAAG,CAAC,EAAE;QAC9BiB,OAAO,CAACiB,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;QAC/D,MAAM,IAAId,KAAK,CAAC,2EAA2E,CAAC;MAC9F;MACAN,OAAO,EAAE;MACT,MAAMb,KAAK,CAACF,WAAW,CAAC;IAC1B;EACF;EAEA,MAAM,IAAIqB,KAAK,CAAC,gCAAgC,CAAC;AACnD,CAAC;AAED,MAAMQ,UAAU,GAAIO,IAAY,IAAa;EAC3C,MAAMC,GAAG,GAAGC,QAAQ,CAACC,aAAa,CAAC,UAAU,CAAC;EAC9CF,GAAG,CAACG,SAAS,GAAGJ,IAAI;EACpB,OAAOC,GAAG,CAACI,KAAK;AAClB,CAAC;AAED,MAAMV,YAAY,GAAOW,KAAU,IAAU;EAC3C,OAAO,CAAC,GAAGA,KAAK,CAAC,CAACC,IAAI,CAAC,MAAMhB,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;AACnD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}